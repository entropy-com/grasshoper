export { merge } from 'ts-deepmerge';

interface XiorRequestConfig<T = any> extends Omit<RequestInit, 'body'> {
    url?: string;
    headers?: Record<string, any>;
    baseURL?: string;
    params?: Record<string, any>;
    /** If no set, default depends on browsers timeout */
    timeout?: number;
    /** @deprecated use paramsSerializer */
    encode?: (params: Record<string, any>) => string;
    paramsSerializer?: (params: Record<string, any>) => string;
    /** Use encodeURIComponent, default: true */
    encodeURI?: boolean;
    /**
     * Currently only support 'json' | 'text', default: 'json';
     * Others will just return the original response
     */
    responseType?: 'json' | 'text' | 'stream' | 'document' | 'arraybuffer' | 'blob' | 'original';
    data?: any;
    /** encoded url with params */
    _url?: string;
    /** useless now, compitable axios */
    withCredentials?: boolean;
    /**
     * some API is get data, but the method is not 'GET',
     * add `isGet: true`, can let the plugins know this is also a `GET` API
     */
    isGet?: boolean;
}
type XiorInterceptorRequestConfig<T = any> = XiorRequestConfig & {
    headers: Record<string, any>;
    params: Record<string, any>;
    url: string;
    _url: string;
    method: string;
};
interface XiorResponse<T = any> {
    data: T;
    status: number;
    statusText: string;
    headers: Headers;
    response: Response;
    config: XiorInterceptorRequestConfig;
    request?: any;
}
type XiorPlugin = (adapter: (request: XiorRequestConfig) => Promise<XiorResponse>) => (request: XiorRequestConfig) => Promise<XiorResponse<any>>;

/** Code Ref: https://github.com/jacobheun/any-signal/pull/40/files */
interface ClearableSignal extends AbortSignal {
    clear: () => void;
}
/**
 * Takes an array of AbortSignals and returns a single signal.
 * If any signals are aborted, the returned signal will be aborted.
 */
declare function anySignal(signals: (AbortSignal | undefined | null)[], cleanCb?: Function): ClearableSignal;

declare function buildSortedURL(_url: string, data: any, encode: (obj: Record<string, any>) => string): string;

declare function delay(ms: number): Promise<unknown>;
type ICacheLike<T> = {
    get(key: string): T | undefined;
    set(key: string, value: T): void;
} & ({
    del(key: string): void;
} | {
    delete(key: string): void;
});

declare function encodeParams<T = any>(params: T, encodeURI?: boolean, parentKey?: string | null): string;
/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
declare function isAbsoluteURL(url: string): boolean;
declare class XiorError extends Error {
    request?: XiorRequestConfig;
    config?: XiorRequestConfig;
    response?: XiorResponse;
    constructor(message: string, request?: XiorRequestConfig, response?: XiorResponse);
}
declare class XiorTimeoutError extends XiorError {
}

declare class xior {
    static create(options?: XiorRequestConfig): xior;
    config?: XiorRequestConfig;
    defaults: XiorInterceptorRequestConfig;
    constructor(options?: XiorRequestConfig);
    private requestInterceptors;
    private responseInterceptors;
    get interceptors(): {
        request: {
            use: (fn: (config: XiorInterceptorRequestConfig) => Promise<XiorInterceptorRequestConfig> | XiorInterceptorRequestConfig, onRejected?: ((error: any) => any) | undefined) => (config: XiorInterceptorRequestConfig) => Promise<XiorInterceptorRequestConfig> | XiorInterceptorRequestConfig;
            eject: (fn: (config: XiorInterceptorRequestConfig) => Promise<XiorInterceptorRequestConfig> | XiorInterceptorRequestConfig) => void;
            clear: () => void;
        };
        response: {
            use: (fn: (config: {
                data: any;
                request: XiorInterceptorRequestConfig;
                response: Response;
            }) => Promise<{
                data: any;
                request: XiorInterceptorRequestConfig;
                response: Response;
            }> | {
                data: any;
                request: XiorInterceptorRequestConfig;
                response: Response;
            }, onRejected?: ((error: XiorError) => any) | undefined) => (config: {
                data: any;
                request: XiorInterceptorRequestConfig;
                response: Response;
            }) => Promise<{
                data: any;
                request: XiorInterceptorRequestConfig;
                response: Response;
            }> | {
                data: any;
                request: XiorInterceptorRequestConfig;
                response: Response;
            };
            eject: (fn: (config: {
                data: any;
                request: XiorInterceptorRequestConfig;
                response: Response;
            }) => Promise<{
                data: any;
                request: XiorInterceptorRequestConfig;
                response: Response;
            }> | {
                data: any;
                request: XiorInterceptorRequestConfig;
                response: Response;
            }) => void;
            clear: () => void;
        };
    };
    private _plugins;
    get plugins(): {
        use: (plugin: XiorPlugin) => XiorPlugin;
        eject: (plugin: XiorPlugin) => void;
        clear: () => void;
    };
    request<T>(options?: XiorRequestConfig | string): Promise<XiorResponse<T>>;
    private handlerFetch;
    private createGetHandler;
    private createPostHandler;
    get<T = any>(url: string, options?: XiorRequestConfig): Promise<XiorResponse<T>>;
    head<T = any>(url: string, options?: XiorRequestConfig): Promise<XiorResponse<T>>;
    post<T = any>(url: string, data?: any, options?: XiorRequestConfig): Promise<XiorResponse<T>>;
    put<T = any>(url: string, data?: any, options?: XiorRequestConfig): Promise<XiorResponse<T>>;
    patch<T = any>(url: string, data?: any, options?: XiorRequestConfig): Promise<XiorResponse<T>>;
    delete<T = any>(url: string, options?: XiorRequestConfig): Promise<XiorResponse<T>>;
    options<T = any>(url: string, data?: any, options?: XiorRequestConfig): Promise<XiorResponse<T>>;
}

export { type ClearableSignal, type ICacheLike, XiorError, type XiorInterceptorRequestConfig, type XiorPlugin, type XiorRequestConfig, type XiorResponse, XiorTimeoutError, anySignal, buildSortedURL, xior as default, delay, encodeParams, isAbsoluteURL, xior };
